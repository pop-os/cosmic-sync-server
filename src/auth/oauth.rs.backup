use log::{debug, error, info, warn};
use reqwest::Client;
use serde::Deserialize;
use crate::models::{Account, AuthToken};
use crate::storage::Storage;
use uuid::Uuid;
use sha2::{Sha256, Digest};
use rand::{RngCore, rngs::OsRng};
use std::sync::Arc;
use chrono::Utc;
use hex;
use std::time::{SystemTime, UNIX_EPOCH};
use crate::auth::{AuthError, Result};
use rand::Rng;
use crate::utils::crypto::generate_account_hash_from_email;
use crate::auth::token::{generate_auth_token, generate_state_token, generate_session_token, extract_account_hash};
use crate::models::device::Device;
/// local test OAuth ÏÑ§Ï†ï
const SYSTEM76_AUTH_URL: &str = "http://localhost:4000/oauth/authorize";
const SYSTEM76_TOKEN_URL: &str = "http://localhost:4000/oauth/token";
const SYSTEM76_USER_INFO_URL: &str = "http://localhost:4000/api/v1/user";
const SYSTEM76_SCOPE: &str = "profile:read";

// OAuth token response structure
#[derive(Debug, Deserialize)]
struct OAuthTokenResponse {
    access_token: String,
    token_type: String,
    expires_in: u64,
    #[serde(default)]
    refresh_token: Option<String>,
}

/// OAuth user info
#[derive(Debug, Deserialize,Clone)]
pub struct OAuthUserInfo {
    pub id: String,
    pub user_id: String,
    pub name: String,
}

/// token verification result
#[derive(Debug, Clone)]
pub struct TokenVerificationResult {
    pub valid: bool,
    pub account_hash: String,
}

/// OAuth authentication service
#[derive(Clone)]
pub struct OAuthService {
    storage: Arc<dyn Storage>,
    client_id: String,
    client_secret: String,
    redirect_uri: String,
}

impl OAuthService {
    /// create new OAuth service
    pub fn new(storage: Arc<dyn Storage>) -> Self {
        let client_id = std::env::var("OAUTH_CLIENT_ID")
            .unwrap_or_else(|_| "cosmic-sync".to_string());
            
        let client_secret = std::env::var("OAUTH_CLIENT_SECRET")
            .unwrap_or_else(|_| "cosmicsecretsocmicsecret".to_string());
            
        let redirect_uri = std::env::var("OAUTH_REDIRECT_URI")
            .unwrap_or_else(|_| "http://localhost:8080/oauth/callback".to_string());
        
        Self { 
            storage,
            client_id,
            client_secret,
            redirect_uri,
        }
    }
    
    /// System76 OAuth login URL
    pub fn generate_oauth_login_url(&self) -> String {
        // generate state token (CSRF prevention)
        let state = generate_state_token();
        
        // Log the state token (session ID)
        info!("Generated OAuth login URL with session ID: {}", state);
        
        // generate System76 login URL
        format!(
            "{}?client_id={}&redirect_uri={}&response_type=code&scope={}&access_type=offline&state={}",
            SYSTEM76_AUTH_URL, self.client_id, self.redirect_uri, SYSTEM76_SCOPE, state
        )
    }
    
    /// System76 OAuth login URL with custom device_hash
    pub fn generate_oauth_login_url_with_device(&self, device_hash: &str) -> String {
        info!("Generated OAuth login URL with custom device_hash: {}", device_hash);
        format!("{}?client_id={}&redirect_uri={}&response_type=code&scope={}&state={}",
            SYSTEM76_AUTH_URL, self.client_id, self.redirect_uri, SYSTEM76_SCOPE, device_hash)
    }
    
    /// validate token and return account hash
    pub async fn validate_token(&self, token: &str) -> Result<String> {
        if token.is_empty() {
            error!("‚ùå ÌÜ†ÌÅ∞Ïù¥ ÎπÑÏñ¥ÏûàÏäµÎãàÎã§");
            return Err(AuthError::InvalidToken("ÌÜ†ÌÅ∞Ïù¥ ÎπÑÏñ¥ÏûàÏäµÎãàÎã§".to_string()));
        }
        
        debug!("üîç Ïù∏Ï¶ù ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù Ï§ë: token_prefix={}", &token[..std::cmp::min(10, token.len())]);
        
        // ÌÖåÏä§Ìä∏ Î™®Îìú ÌôïÏù∏
        if cfg!(debug_assertions) && token == "test_token" {
            debug!("‚úÖ ÌÖåÏä§Ìä∏ Î™®ÎìúÏóêÏÑú token='test_token' Í∞êÏßÄÎê®, Ï¶âÏãú Í≤ÄÏ¶ùÎê®");
            return Ok("test_account_hash".to_string());
        }
        
        // Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú ÌÜ†ÌÅ∞ Ï°∞Ìöå
        match self.storage.get_auth_token(token).await {
            Ok(Some(token_obj)) => {
                debug!("üîç ÌÜ†ÌÅ∞ Í∞ùÏ≤¥ Î∞úÍ≤¨: account_hash={}, expires_at={}", 
                       token_obj.account_hash, token_obj.expires_at);
                
                // ÌÜ†ÌÅ∞ ÎßåÎ£å Ïó¨Î∂Ä ÌôïÏù∏
                let now = Utc::now();
                if token_obj.expires_at < now {
                    error!("‚ùå ÌÜ†ÌÅ∞Ïù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§: expires_at={}, now={}", token_obj.expires_at, now);
                    return Err(AuthError::InvalidToken("ÌÜ†ÌÅ∞Ïù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§".to_string()));
                }
                
                if !token_obj.is_valid {
                    error!("‚ùå ÌÜ†ÌÅ∞Ïù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§: account_hash={}", token_obj.account_hash);
                    return Err(AuthError::InvalidToken("ÌÜ†ÌÅ∞Ïù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§".to_string()));
                }
                
                debug!("‚úÖ ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù ÏÑ±Í≥µ: account_hash={}", token_obj.account_hash);
                Ok(token_obj.account_hash)
            },
            Ok(None) => {
                error!("‚ùå ÌÜ†ÌÅ∞ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: token_prefix={}", &token[..std::cmp::min(10, token.len())]);
                Err(AuthError::InvalidToken("ÌÜ†ÌÅ∞ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§".to_string()))
            },
            Err(e) => {
                error!("‚ùå ÌÜ†ÌÅ∞ Ï°∞Ìöå Ï§ë Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïò§Î•ò: {}", e);
                Err(AuthError::DatabaseError(e.to_string()))
            }
        }
    }
    
    /// validate token and return result (used in handler)
    pub async fn verify_token(&self, token: &str) -> Result<TokenVerificationResult> {
        match self.validate_token(token).await {
            Ok(account_hash) => {
                Ok(TokenVerificationResult {
                    valid: true,
                    account_hash,
                })
            },
            Err(_) => {
                Ok(TokenVerificationResult {
                    valid: false,
                    account_hash: String::new(),
                })
            }
        }
    }
    
    /// exchange oauth code and authenticate
    pub async fn exchange_oauth_code_and_authenticate(&self, code: &str) -> Result<(String, OAuthUserInfo)> {
        // 1. exchange code to access token
        let token = self.exchange_oauth_code(code).await?;
        
        // 2. get user info with access token
        let user_info = self.get_user_info_with_token(&token).await?;
        
        Ok((token, user_info))
    }
    
    /// exchange oauth code to access token
    pub async fn exchange_oauth_code(&self, code: &str) -> Result<String> {
        // OAuth provider settings
        let client_id = std::env::var("OAUTH_CLIENT_ID")
            .unwrap_or_else(|_| "cosmic-sync".to_string());
        
        let client_secret = std::env::var("OAUTH_CLIENT_SECRET")
            .unwrap_or_else(|_| "cosmicsecretsocmicsecret".to_string());
        
        let redirect_uri = std::env::var("OAUTH_REDIRECT_URI")
            .unwrap_or_else(|_| "http://localhost:8080/oauth/callback".to_string());
        
        // create http client
        let client = Client::new();
        
        // token request parameters
        let params = [
            ("code", code),
            ("client_id", &client_id),
            ("client_secret", &client_secret),
            ("redirect_uri", &redirect_uri),
            ("grant_type", "authorization_code"),
        ];
        
        #[derive(Deserialize)]
        struct TokenResponse {
            access_token: String,
            #[serde(default)]
            refresh_token: Option<String>,
            #[serde(default)]
            expires_in: Option<u64>,
        }
        
        // send token request
        info!("Exchanging OAuth code for access token");
        
        // currently in test mode, so do not send actual request
        if cfg!(debug_assertions) {
            return Ok("test_access_token".to_string());
        }
        
        // send token request to System76 token URL
        match client.post(SYSTEM76_TOKEN_URL)
            .form(&params)
            .send()
            .await {
                Ok(response) => {
                    if response.status().is_success() {
                        match response.json::<TokenResponse>().await {
                            Ok(token_data) => {
                                info!("Successfully exchanged OAuth code for access token");
                                Ok(token_data.access_token)
                            },
                            Err(e) => {
                                error!("Failed to parse token response: {}", e);
                                Err(AuthError::ExternalServiceError(format!("Failed to parse token response: {}", e)))
                            }
                        }
                    } else {
                        let status = response.status();
                        let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
                        error!("OAuth token exchange failed: {} - {}", status, error_text);
                        Err(AuthError::ExternalServiceError(format!("OAuth token exchange failed: {} - {}", status, error_text)))
                    }
                },
                Err(e) => {
                    error!("Failed to send token request: {}", e);
                    Err(AuthError::ExternalServiceError(format!("Failed to send token request: {}", e)))
                }
            }
    }
    
    /// get user info with access token (System76)
    async fn get_user_info_with_token(&self, access_token: &str) -> Result<OAuthUserInfo> {
        // create http client
        let client = Client::new();
        
        // test mode
        if cfg!(debug_assertions) {
            return Ok(OAuthUserInfo {
                id: "test_user_id".to_string(),
                user_id: "test@example.com".to_string(),
                name: "Test User".to_string(),
            });
        }
        
        // send user info request to System76 user info URL
        match client.get(SYSTEM76_USER_INFO_URL)
            .header("Authorization", format!("Bearer {}", access_token))
            .send()
            .await {
                Ok(response) => {
                    if response.status().is_success() {
                        match response.json::<OAuthUserInfo>().await {
                            Ok(user_info) => {
                                Ok(OAuthUserInfo {
                                    id: user_info.id,
                                    user_id: user_info.user_id,
                                    name: user_info.name.clone(),
                                })
                            },
                            Err(e) => {
                                Err(AuthError::ExternalServiceError(format!("Failed to parse user info response: {}", e)))
                            }
                        }
                    } else {
                        let status = response.status();
                        let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
                        Err(AuthError::ExternalServiceError(format!("Failed to send user info request: {} - {}", status, error_text)))
                    }
                },
                Err(e) => {
                    Err(AuthError::ExternalServiceError(format!("Failed to send user info request: {}", e)))
                }
            }
    }
}

/// exchange oauth code and process user authentication and account info
pub async fn process_oauth_code(
    code: &str,
    oauth_service: Arc<OAuthService>,
) -> Result<(String, String, String)> {
    // 1. exchange oauth code to access token and get user info
    let (_access_token, user_info) = match oauth_service.exchange_oauth_code_and_authenticate(code).await {
        Ok(result) => result,
        Err(e) => {
            error!("OAuth authentication failed: {}", e);
            return Err(AuthError::ExternalServiceError(format!("OAuth authentication failed: {}", e)));
        }
    };
    
    info!("User authenticated: {} ({})", user_info.user_id, user_info.id);
    
    // 2. hash user info to generate account hash
    let account_hash = generate_account_hash_from_email(&user_info.user_id, &user_info.name);
    
    // 3. save or update user info to db
    let _account_obj = match oauth_service.storage.get_account_by_hash(&account_hash).await {
        Ok(Some(account)) => {
            info!("üîÑ Í∏∞Ï°¥ Í≥ÑÏ†ï Î∞úÍ≤¨, Î°úÍ∑∏Ïù∏ ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏: account_hash={}", account_hash);
            // ÎßàÏßÄÎßâ Î°úÍ∑∏Ïù∏ ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
            if let Err(e) = oauth_service.storage.update_account(&account).await {
                error!("Error updating account last login: {}", e);
            }
            account
        },
        Ok(None) => {
            info!("‚ú® ÏÉà Í≥ÑÏ†ï ÏÉùÏÑ± Ï§ë: account_hash={}, user_id={}", account_hash, user_info.user_id);
            // Í≥ÑÏ†ïÏù¥ ÏóÜÏúºÎ©¥ ÏÉàÎ°ú ÏÉùÏÑ±
            let now = Utc::now();
            let new_account = Account {
                account_hash: account_hash.clone(),
                user_id: user_info.user_id.clone(),
                name: user_info.name.clone(),
                email: format!("{}@example.com", user_info.user_id),
                id: Uuid::new_v4().to_string(),
                user_type: "oauth".to_string(),
                password_hash: String::new(),
                salt: String::new(),
                is_active: true,
                created_at: now,
                updated_at: now,
                last_login: now,
            };
            
            // Í≥ÑÏ†ï Ï†ÄÏû•
            if let Err(e) = oauth_service.storage.create_account(&new_account).await {
                error!("‚ùå Í≥ÑÏ†ï ÏÉùÏÑ± Ïã§Ìå®: {}", e);
            } else {
                info!("‚úÖ ÏÉà Í≥ÑÏ†ï ÏÉùÏÑ± ÏôÑÎ£å: account_hash={}", account_hash);
            }
            
            new_account
        },
        Err(e) => {
            error!("Error getting account: {}", e);
            return Err(AuthError::DatabaseError(e.to_string()));
        }
    };
    
    // 4. generate auth token
    let auth_token = generate_auth_token();
    
    // Create and save auth token
    let token_obj = AuthToken {
        token_id: Uuid::new_v4().to_string(),
        account_hash: account_hash.clone(),
        access_token: auth_token.clone(),
        token_type: "Bearer".to_string(),
        refresh_token: None,
        created_at: Utc::now(),
        expires_at: Utc::now() + chrono::Duration::hours(24),
        is_valid: true,
        scope: None,
    };
    
    // Save auth token
    if let Err(e) = oauth_service.storage.create_auth_token(&token_obj).await {
        error!("Error saving auth token: {}", e);
        return Err(AuthError::DatabaseError(format!("Error saving auth token: {}", e)));
    }
    
    // 5. generate or get user's encryption key
    let encryption_key = match get_encryption_key(&account_hash, oauth_service.storage.clone()).await {
        Ok(Some(key)) => key,
        Ok(None) => String::new(),
        Err(e) => {
            error!("Failed to get encryption key: {}", e);
            String::new()
        }
    };
    
    Ok((auth_token, account_hash, encryption_key))
}

/// get user info with access token
pub async fn get_oauth_user_info(access_token: &str) -> Result<OAuthUserInfo> {
    // create http client
    let client = Client::new();
    
    info!("Fetching System76 user info with access token");
    
    // test mode 
    if cfg!(debug_assertions) {
        return Ok(OAuthUserInfo {
            id: "test_user_id".to_string(),
            user_id: "test@example.com".to_string(),
            name: "Test User".to_string(),
        });
    }
    
    // System76 user info request
    match client.get(SYSTEM76_USER_INFO_URL)
        .header("Authorization", format!("Bearer {}", access_token))
        .send()
        .await {
            Ok(response) => {
                if response.status().is_success() {
                        // System76 API response parsing
                    match response.json::<OAuthUserInfo>().await {
                        Ok(system76_user) => {
                            info!("Successfully fetched user info for: {}", system76_user.user_id);
                            
                            // System76 user info to OAuthUserInfo
                            Ok(OAuthUserInfo {
                                id: system76_user.id,
                                user_id: system76_user.user_id,
                                name: system76_user.name.clone(),
                            })
                        },
                        Err(e) => {
                            error!("Failed to parse System76 user info response: {}", e);
                            Err(AuthError::ExternalServiceError(format!("Failed to parse System76 user info response: {}", e)))
                        }
                    }
                } else {
                    let status = response.status();
                    let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
                    error!("System76 user info request failed: {} - {}", status, error_text);
                    Err(AuthError::ExternalServiceError(format!("System76 user info request failed: {} - {}", status, error_text)))
                }
            },
            Err(e) => {
                error!("Failed to send System76 user info request: {}", e);
                Err(AuthError::ExternalServiceError(format!("Failed to send System76 user info request: {}", e)))
            }
        }
}

/// get or generate user's encryption key
async fn get_encryption_key(account_hash: &str, storage: Arc<dyn Storage>) -> Result<Option<String>> {
    // get account encryption key
    match storage.get_encryption_key(account_hash).await {
        Ok(Some(key)) => {
            debug!("Found existing encryption key for account: {}", account_hash);
            return Ok(Some(key));
        },
        Ok(None) => {
            debug!("No encryption key found for account: {}, will generate a new one", account_hash);
        },
        Err(e) => {
            error!("Error fetching encryption key from storage: {}", e);
            // if error occurs, generate a new one
        }
    }
    
    // try to get encryption key from existing devices
    let devices = match storage.list_devices(account_hash).await {
        Ok(device_list) => device_list,
        Err(e) => {
            error!("Error getting devices for account {}: {}", account_hash, e);
            Vec::new()
        }
    };
    
    // if there are existing devices, print the first device id
    if !devices.is_empty() {
        let device_hash = &devices[0].device_hash;
        debug!("Using existing device for encryption key: {}", device_hash);
    }
    
    // generate a new encryption key
    let mut key = [0u8; 32];
    OsRng.fill_bytes(&mut key);
    let encryption_key = hex::encode(key);
    
    // store the new encryption key
    if let Err(e) = storage.store_encryption_key(account_hash, &encryption_key).await {
        error!("Failed to store new encryption key: {}", e);
    } else {
        debug!("Successfully stored new encryption key for account: {}", account_hash);
    }
    
    Ok(Some(encryption_key))
}