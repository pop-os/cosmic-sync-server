use std::sync::Arc;
use tonic::{Request, Response, Status};
use futures::StreamExt;
pub use crate::sync::sync_service_server::SyncService;
use crate::sync::sync_client_service_server::SyncClientService;
use crate::sync::{
    OAuthExchangeRequest, OAuthExchangeResponse,
    RegisterDeviceRequest, RegisterDeviceResponse,
    ListDevicesRequest, ListDevicesResponse,
    DeleteDeviceRequest, DeleteDeviceResponse,
    RequestEncryptionKeyRequest, RequestEncryptionKeyResponse,
    UploadFileRequest, UploadFileResponse,
    DownloadFileRequest, DownloadFileResponse,
    ListFilesRequest, ListFilesResponse,
    DeleteFileRequest, DeleteFileResponse,
    HealthCheckRequest, HealthCheckResponse,
    UpdateDeviceInfoRequest, UpdateDeviceInfoResponse,
    ValidateTokenRequest, ValidateTokenResponse,
    LoginRequest, LoginResponse,
    VerifyLoginRequest, VerifyLoginResponse,
    CheckAuthStatusRequest, CheckAuthStatusResponse,
    RegisterWatcherPresetRequest, RegisterWatcherPresetResponse,
    UpdateWatcherPresetRequest, UpdateWatcherPresetResponse,
    GetWatcherPresetRequest, GetWatcherPresetResponse,
    RegisterWatcherGroupRequest, RegisterWatcherGroupResponse,
    UpdateWatcherGroupRequest, UpdateWatcherGroupResponse,
    DeleteWatcherGroupRequest, DeleteWatcherGroupResponse,
    GetWatcherGroupRequest, GetWatcherGroupResponse,
    SyncConfigurationRequest, SyncConfigurationResponse,
    AuthSuccessNotification, AuthNotificationResponse,
    GetWatcherGroupsRequest, GetWatcherGroupsResponse,
    GetFileHistoryRequest, GetFileHistoryResponse,
    RestoreFileVersionRequest, RestoreFileVersionResponse,
    BroadcastFileRestoreRequest, BroadcastFileRestoreResponse,
    VersionUpdateNotification,
    SubscribeRequest,
    AuthUpdateNotification,
    DeviceUpdateNotification,
    EncryptionKeyUpdateNotification,
    FileUpdateNotification,
    WatcherPresetUpdateNotification,
    WatcherGroupUpdateNotification,
    GetAccountInfoRequest,
    GetAccountInfoResponse,
    FindFileRequest,
    FindFileResponse,
    CheckFileExistsRequest,
    CheckFileExistsResponse,
};
use crate::services::{Handler};
use crate::handlers::{
    AuthHandler,
    DeviceHandler,
    FileHandler,
    WatcherHandler,
    SyncHandler,
};
use crate::server::app_state::AppState;
use tracing::{debug, error, info, warn};
use std::pin::Pin;
use futures::Stream;
use tokio::sync::mpsc;
use tokio_stream::wrappers::ReceiverStream;
use crate::auth::oauth::OAuthService;

/// Synchronization service implementation
pub struct SyncServiceImpl {
    /// Application state
    pub app_state: Arc<AppState>,
    /// OAuth service
    oauth: Arc<OAuthService>,
    /// Authentication handler
    auth_handler: AuthHandler,
    /// Device handler
    device_handler: DeviceHandler,
    /// File handler
    file_handler: FileHandler,
    /// Watcher handler
    watcher_handler: WatcherHandler,
    /// Sync handler
    sync_handler: SyncHandler,
}

impl SyncServiceImpl {
    /// Create a new SyncServiceImpl instance
    pub fn new(app_state: Arc<AppState>) -> Self {
        let auth_handler = AuthHandler::new(app_state.clone());
        
        let device_handler = DeviceHandler::new(app_state.clone());
        
        let file_handler = FileHandler::new(app_state.clone());
        
        let watcher_handler = WatcherHandler::new(app_state.clone());
        
        let sync_handler = SyncHandler::new(app_state.clone());
        
        Self {
            oauth: Arc::new(app_state.oauth.clone()),
            app_state,
            auth_handler,
            device_handler,
            file_handler,
            watcher_handler,
            sync_handler,
        }
    }

    async fn validate_auth(&self, auth_token: &str, account_hash: &str) -> Result<(), Status> {
        debug!("Auth validation started: account_hash={}, token_length={}", account_hash, auth_token.len());
        
        if auth_token.is_empty() {
            error!("Empty auth token provided for account: {}", account_hash);
            return Err(Status::unauthenticated("Empty authentication token"));
        }
        
        // oauthÎ•º ÌÜµÌï¥ ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù
        match self.app_state.oauth.verify_token(auth_token).await {
            Ok(auth_result) => {
                debug!("Token verification result: valid={}, token_account={}, expected_account={}", 
                       auth_result.valid, auth_result.account_hash, account_hash);
                
                if auth_result.valid && auth_result.account_hash == account_hash {
                    debug!("Auth validation successful for account: {}", account_hash);
                    Ok(())
                } else {
                    error!("Auth validation failed: token valid={}, expected_account={}, actual_account={}", 
                           auth_result.valid, account_hash, auth_result.account_hash);
                    Err(Status::unauthenticated("Invalid authentication"))
                }
            },
            Err(e) => {
                error!("Token verification error for account {}: {}", account_hash, e);
                Err(Status::unauthenticated("Invalid authentication"))
            }
        }
    }
    
    /// ÏÉàÎ°ú Íµ¨ÎèÖÌïú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÍ≤å Í∏∞Ï°¥ ÌååÏùºÎì§Ïóê ÎåÄÌïú Ï¥àÍ∏∞ ÎèôÍ∏∞Ìôî ÏïåÎ¶º Ï†ÑÏÜ° (Í∞úÏÑ†Îêú Î≤ÑÏ†Ñ)
    async fn send_initial_file_sync(&self, account_hash: &str, device_hash: &str) -> Result<(), Status> {
        info!("üîÑ Starting enhanced initial file sync for device: {}:{}", account_hash, device_hash);
        
        // Ïó∞Í≤∞ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        let connection_key = format!("{}:{}", account_hash, device_hash);
        self.app_state.connection_tracker.update_sync_time(&connection_key).await;
        
        // Ìï¥Îãπ Í≥ÑÏ†ïÏùò Î™®Îì† ÌôúÏÑ± ÌååÏùº Ï°∞Ìöå
                        let files = match self.app_state.storage.list_files(account_hash, 1, None).await {
            Ok(files) => files,
            Err(e) => {
                error!("Failed to list files for initial sync: {}", e);
                return Err(Status::internal("Failed to retrieve files for initial sync"));
            }
        };
        
        let mut sync_count = 0;
        let mut skip_count = 0;
        let subscriber_key = format!("{}:{}", account_hash, device_hash);
        
        // Î∞∞Ïπò ÌÅ¨Í∏∞ ÏÑ§Ï†ï (Ìïú Î≤àÏóê ÎÑàÎ¨¥ ÎßéÏùÄ ÏïåÎ¶ºÏùÑ Î≥¥ÎÇ¥ÏßÄ ÏïäÎèÑÎ°ù)
        const BATCH_SIZE: usize = 50;
        let total_files = files.len();
        
        // Í∞Å ÌååÏùºÏóê ÎåÄÌï¥ Î∞∞Ïπò Ï≤òÎ¶¨Î°ú Í∞úÎ≥Ñ ÏïåÎ¶º Ï†ÑÏÜ°
        for (batch_idx, batch) in files.chunks(BATCH_SIZE).enumerate() {
            debug!("üì¶ Processing batch {}/{} ({} files)", 
                   batch_idx + 1, (total_files + BATCH_SIZE - 1) / BATCH_SIZE, batch.len());
            
            for file in batch {
                                        // Skip files that are logically deleted (check by status or other field if available)
                        // Note: is_deleted field not available in current FileInfo struct
                
                // Í∞ôÏùÄ Ïû•ÏπòÏóêÏÑú ÏóÖÎ°úÎìúÎêú ÌååÏùºÏùÄ Ï†úÏô∏ (ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä Ïù¥ÎØ∏ Í∞ÄÏßÄÍ≥† ÏûàÏùå)
                if file.device_hash == device_hash {
                    skip_count += 1;
                    debug!("‚è≠Ô∏è Skipping file {} (same device: {})", file.filename, device_hash);
                    continue;
                }
                
                                        // ÌååÏùº ÏóÖÎç∞Ïù¥Ìä∏ ÏïåÎ¶º ÏÉùÏÑ±
                        let file_info = crate::sync::FileInfo {
                            file_id: file.file_id as u64,
                            filename: file.filename.clone(),
                            file_hash: file.file_hash.clone(),
                            device_hash: file.device_hash.clone(),
                            group_id: file.group_id,
                            watcher_id: file.watcher_id,
                            file_path: file.file_path.clone(),
                            file_size: file.size as u64,
                            revision: file.revision,
                            is_encrypted: file.is_encrypted,
                            updated_time: Some(prost_types::Timestamp {
                                seconds: file.updated_time.seconds,
                                nanos: file.updated_time.nanos,
                            }),
                        };
                        
                        let file_update_notification = crate::sync::FileUpdateNotification {
                            account_hash: account_hash.to_string(),
                            device_hash: file.device_hash.clone(),
                            file_info: Some(file_info),
                            update_type: crate::sync::file_update_notification::UpdateType::Uploaded as i32,
                            timestamp: file.updated_time.seconds,
                        };
                
                                        // ÌäπÏ†ï Íµ¨ÎèÖÏûêÏóêÍ≤åÎßå Ï†ÑÏÜ° (ÏÉàÎ°ú Ïó∞Í≤∞Îêú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏)
                        if let Some(sender) = {
                            let subscribers = self.app_state.notification_manager.get_file_update_subscribers().lock().await;
                            subscribers.get(&subscriber_key).cloned()
                        } {
                    match sender.send(Ok(file_update_notification)).await {
                        Ok(_) => {
                            sync_count += 1;
                            debug!("üì§ Initial sync notification sent for file: {} ({})", file.filename, file.file_id);
                        },
                        Err(e) => {
                            warn!("Failed to send initial sync notification for file {}: {}", file.filename, e);
                            break; // Ï†ÑÏÜ° Ïã§Ìå® Ïãú Ïù¥ Î∞∞Ïπò Ï§ëÎã®
                        }
                    }
                } else {
                    warn!("Subscriber {} not found during initial sync", subscriber_key);
                    break; // Íµ¨ÎèÖÏûêÍ∞Ä ÏóÜÏúºÎ©¥ Ï§ëÎã®
                }
            }
            
            // Î∞∞Ïπò Í∞Ñ ÏßßÏùÄ ÏßÄÏó∞ (Ï±ÑÎÑêÏù¥ ÎßâÌûàÎäî Í≤ÉÏùÑ Î∞©ÏßÄ)
            if batch_idx + 1 < (total_files + BATCH_SIZE - 1) / BATCH_SIZE {
                tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
            }
        }
        
        info!("üéâ Enhanced initial file sync completed: {} files synced, {} skipped, total processed: {} for {}:{}", 
              sync_count, skip_count, total_files, account_hash, device_hash);
        Ok(())
    }
}

#[tonic::async_trait]
impl SyncService for SyncServiceImpl {
    // Ïó∞Í¥Ä ÌÉÄÏûÖ Î™ÖÏãúÏ†Å Ï†ïÏùò
    type SubscribeToAuthUpdatesStream = Pin<Box<dyn Stream<Item = Result<AuthUpdateNotification, Status>> + Send + 'static>>;
    type SubscribeToDeviceUpdatesStream = Pin<Box<dyn Stream<Item = Result<DeviceUpdateNotification, Status>> + Send + 'static>>;
    type SubscribeToEncryptionKeyUpdatesStream = Pin<Box<dyn Stream<Item = Result<EncryptionKeyUpdateNotification, Status>> + Send + 'static>>;
    type SubscribeToFileUpdatesStream = Pin<Box<dyn Stream<Item = Result<FileUpdateNotification, Status>> + Send + 'static>>;
    type SubscribeToWatcherPresetUpdatesStream = Pin<Box<dyn Stream<Item = Result<WatcherPresetUpdateNotification, Status>> + Send + 'static>>;
    type SubscribeToWatcherGroupUpdatesStream = Pin<Box<dyn Stream<Item = Result<WatcherGroupUpdateNotification, Status>> + Send + 'static>>;

    // OAuth related methods
    async fn exchange_oauth_code(
        &self,
        request: Request<OAuthExchangeRequest>,
    ) -> Result<Response<OAuthExchangeResponse>, Status> {
        debug!("OAuth code exchange request received");
        self.auth_handler.handle_oauth_exchange(request).await
    }
    
    // Device related methods
    async fn register_device(
        &self,
        request: Request<RegisterDeviceRequest>,
    ) -> Result<Response<RegisterDeviceResponse>, Status> {
        debug!("Device registration request received");
        self.device_handler.handle_register_device(request).await
    }
    
    async fn list_devices(
        &self,
        request: Request<ListDevicesRequest>,
    ) -> Result<Response<ListDevicesResponse>, Status> {
        debug!("Device list request received");
        self.device_handler.handle_list_devices(request).await
    }
    
    async fn delete_device(
        &self,
        request: Request<DeleteDeviceRequest>,
    ) -> Result<Response<DeleteDeviceResponse>, Status> {
        debug!("Device deletion request received");
        self.device_handler.handle_delete_device(request).await
    }
    
    async fn update_device_info(
        &self,
        request: Request<UpdateDeviceInfoRequest>,
    ) -> Result<Response<UpdateDeviceInfoResponse>, Status> {
        debug!("Device info update request received");
        self.device_handler.handle_update_device_info(request).await
    }
    
    // Encryption key related methods
    async fn request_encryption_key(
        &self,
        request: Request<RequestEncryptionKeyRequest>,
    ) -> Result<Response<RequestEncryptionKeyResponse>, Status> {
        debug!("Encryption key request received");
        self.sync_handler.handle_request_encryption_key(request).await
    }
    
    // File related methods
    async fn upload_file(
        &self,
        request: Request<UploadFileRequest>,
    ) -> Result<Response<UploadFileResponse>, Status> {
        debug!("File upload request received");
        self.file_handler.handle_upload_file(request).await
    }
    
    async fn download_file(
        &self,
        request: Request<DownloadFileRequest>,
    ) -> Result<Response<DownloadFileResponse>, Status> {
        debug!("File download request received");
        self.file_handler.handle_download_file(request).await
    }
    
    async fn list_files(
        &self,
        request: Request<ListFilesRequest>,
    ) -> Result<Response<ListFilesResponse>, Status> {
        debug!("File list request received");
        self.file_handler.handle_list_files(request).await
    }
    
    async fn delete_file(
        &self,
        request: Request<DeleteFileRequest>,
    ) -> Result<Response<DeleteFileResponse>, Status> {
        debug!("File deletion request received");
        self.file_handler.handle_delete_file(request).await
    }
    
    async fn find_file_by_criteria(
        &self,
        request: Request<FindFileRequest>,
    ) -> Result<Response<FindFileResponse>, Status> {
        debug!("Find file by criteria request received");
        self.file_handler.handle_find_file_by_criteria(request).await
    }
    
    /// CheckFileExists - ÌååÏùº Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏ (ÏÇ≠Ï†úÎêú ÌååÏùºÎèÑ Ìè¨Ìï®)
    async fn check_file_exists(&self, request: Request<CheckFileExistsRequest>) -> Result<Response<CheckFileExistsResponse>, Status> {
        debug!("Check file exists request received");
        self.file_handler.handle_check_file_exists(request).await
    }
    
    // WatcherPreset related methods
    async fn register_watcher_preset(
        &self,
        request: Request<RegisterWatcherPresetRequest>,
    ) -> Result<Response<RegisterWatcherPresetResponse>, Status> {
        debug!("Register watcher preset request received");
        self.watcher_handler.handle_register_watcher_preset(request).await
    }
    
    async fn update_watcher_preset(
        &self,
        request: Request<UpdateWatcherPresetRequest>,
    ) -> Result<Response<UpdateWatcherPresetResponse>, Status> {
        debug!("Update watcher preset request received");
        self.watcher_handler.handle_update_watcher_preset(request).await
    }
    
    async fn get_watcher_preset(
        &self,
        request: Request<GetWatcherPresetRequest>,
    ) -> Result<Response<GetWatcherPresetResponse>, Status> {
        debug!("Get watcher preset request received");
        self.watcher_handler.handle_get_watcher_preset(request).await
    }
    
    // WatcherGroup related methods
    async fn register_watcher_group(
        &self,
        request: Request<RegisterWatcherGroupRequest>,
    ) -> Result<Response<RegisterWatcherGroupResponse>, Status> {
        debug!("Register watcher group request received");
        self.watcher_handler.handle_register_watcher_group(request).await
    }
    
    async fn update_watcher_group(
        &self,
        request: Request<UpdateWatcherGroupRequest>,
    ) -> Result<Response<UpdateWatcherGroupResponse>, Status> {
        debug!("Update watcher group request received");
        self.watcher_handler.handle_update_watcher_group(request).await
    }
    
    async fn delete_watcher_group(
        &self,
        request: Request<DeleteWatcherGroupRequest>,
    ) -> Result<Response<DeleteWatcherGroupResponse>, Status> {
        debug!("Delete watcher group request received");
        self.watcher_handler.handle_delete_watcher_group(request).await
    }
    
    async fn get_watcher_group(
        &self,
        request: Request<GetWatcherGroupRequest>,
    ) -> Result<Response<GetWatcherGroupResponse>, Status> {
        debug!("Get watcher group request received");
        self.watcher_handler.handle_get_watcher_group(request).await
    }
    
    async fn get_watcher_groups(
        &self,
        request: Request<GetWatcherGroupsRequest>,
    ) -> Result<Response<GetWatcherGroupsResponse>, Status> {
        debug!("Get watcher groups request received");
        self.watcher_handler.handle_get_watcher_groups(request).await
    }
    
    // Health check method
    async fn health_check(
        &self,
        request: Request<HealthCheckRequest>,
    ) -> Result<Response<HealthCheckResponse>, Status> {
        debug!("Health check request received");
        self.sync_handler.handle_health_check(request).await
    }
    
    // Token validation
    async fn validate_token(
        &self,
        request: Request<ValidateTokenRequest>,
    ) -> Result<Response<ValidateTokenResponse>, Status> {
        debug!("Token validation request received");
        self.auth_handler.handle_validate_token(request).await
    }
    
    // Authentication status check
    async fn check_auth_status(
        &self,
        request: Request<CheckAuthStatusRequest>,
    ) -> Result<Response<CheckAuthStatusResponse>, Status> {
        debug!("Auth status check request received");
        
        // ÏöîÏ≤≠ÏóêÏÑú device_hash Ï∂îÏ∂ú Î∞è ÌÅ¥Î°† (ÏÜåÏú†Í∂å Î¨∏Ï†ú Ìï¥Í≤∞)
        let device_hash = request.get_ref().device_hash.clone();
        info!("Check auth status for device_hash: {}", device_hash);
        
        // AuthHandlerÏùò check_auth_status Ìò∏Ï∂ú
        let result = self.auth_handler.check_auth_status(request).await;
        
        // ÏùëÎãµ Î°úÍπÖ (ÏÑ±Í≥µ/Ïã§Ìå®)
        match &result {
            Ok(response) => {
                let resp = response.get_ref();
                if resp.is_complete {
                    info!("Auth status check: authenticated for device_hash: {}", device_hash);
                } else {
                    info!("Auth status check: not yet authenticated for device_hash: {}", device_hash);
                }
            },
            Err(e) => {
                error!("Auth status check error: {}", e);
            }
        }
        
        result
    }
    
    // Login method
    async fn login(
        &self,
        request: Request<LoginRequest>,
    ) -> Result<Response<LoginResponse>, Status> {
        debug!("Login request received");
        self.auth_handler.handle_login(request).await
    }
    
    // Login verification
    async fn verify_login(
        &self,
        request: Request<VerifyLoginRequest>,
    ) -> Result<Response<VerifyLoginResponse>, Status> {
        debug!("Login verification request received");
        self.auth_handler.handle_verify_login(request).await
    }
    
    // Í≥ÑÏ†ï Ï†ïÎ≥¥ Ï°∞Ìöå
    async fn get_account_info(
        &self,
        request: Request<GetAccountInfoRequest>,
    ) -> Result<Response<GetAccountInfoResponse>, Status> {
        debug!("Account info request received");
        self.auth_handler.handle_get_account_info(request).await
    }
    
    // ÌÜµÌï© ÏÑ§Ï†ï ÎèôÍ∏∞Ìôî
    async fn sync_configuration(
        &self,
        request: Request<SyncConfigurationRequest>,
    ) -> Result<Response<SyncConfigurationResponse>, Status> {
        debug!("Integrated configuration sync request received");
        self.watcher_handler.handle_sync_configuration(request).await
    }
    
    // Ïä§Ìä∏Î¶¨Î∞ç Íµ¨ÎèÖ Î©îÏÑúÎìú Íµ¨ÌòÑ
    async fn subscribe_to_auth_updates(
        &self,
        request: Request<SubscribeRequest>,
    ) -> Result<Response<Self::SubscribeToAuthUpdatesStream>, Status> {
        debug!("Auth updates subscription request received");
        
        let (tx, rx) = mpsc::channel(128);
        let stream = ReceiverStream::new(rx);
        
        // TODO: Ïã§Ï†ú ÏÇ¨Ïö©Ïûê Ïù∏Ï¶ù ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ Î∞è ÏóÖÎç∞Ïù¥Ìä∏ Î°úÏßÅ Íµ¨ÌòÑ
        tokio::spawn(async move {
            // Ìñ•ÌõÑ Ïã§Ï†ú Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ° Î°úÏßÅ Íµ¨ÌòÑ
        });
        
        Ok(Response::new(Box::pin(stream) as Self::SubscribeToAuthUpdatesStream))
    }
    
    async fn subscribe_to_device_updates(
        &self,
        request: Request<SubscribeRequest>,
    ) -> Result<Response<Self::SubscribeToDeviceUpdatesStream>, Status> {
        debug!("Device updates subscription request received");
        
        let (tx, rx) = mpsc::channel(128);
        let stream = ReceiverStream::new(rx);
        
        // TODO: Ïã§Ï†ú Ïû•Ïπò ÏóÖÎç∞Ïù¥Ìä∏ Î™®ÎãàÌÑ∞ÎßÅ Íµ¨ÌòÑ
        tokio::spawn(async move {
            // Ìñ•ÌõÑ Ïã§Ï†ú Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ° Î°úÏßÅ Íµ¨ÌòÑ
        });
        
        Ok(Response::new(Box::pin(stream) as Self::SubscribeToDeviceUpdatesStream))
    }
    
    async fn subscribe_to_encryption_key_updates(
        &self,
        request: Request<SubscribeRequest>,
    ) -> Result<Response<Self::SubscribeToEncryptionKeyUpdatesStream>, Status> {
        debug!("Encryption key updates subscription request received");
        
        let (tx, rx) = mpsc::channel(128);
        let stream = ReceiverStream::new(rx);
        
        // TODO: Ïã§Ï†ú ÏïîÌò∏Ìôî ÌÇ§ ÏóÖÎç∞Ïù¥Ìä∏ Î™®ÎãàÌÑ∞ÎßÅ Íµ¨ÌòÑ
        tokio::spawn(async move {
            // Ìñ•ÌõÑ Ïã§Ï†ú Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ° Î°úÏßÅ Íµ¨ÌòÑ
        });
        
        Ok(Response::new(Box::pin(stream) as Self::SubscribeToEncryptionKeyUpdatesStream))
    }
    
    async fn subscribe_to_file_updates(
        &self,
        request: Request<SubscribeRequest>,
    ) -> Result<Response<Self::SubscribeToFileUpdatesStream>, Status> {
        let req = request.into_inner();
        let device_hash = req.device_hash;
        
        info!("File updates subscription request received from device_hash: {}", device_hash);
        
        // Î®ºÏ†Ä ÌÜ†ÌÅ∞ÏùÑ Í≤ÄÏ¶ùÌïòÍ≥† Ïã§Ï†ú account_hashÎ•º Í∞ÄÏ†∏Ïò¥
        let auth_result = match self.app_state.oauth.verify_token(&req.auth_token).await {
            Ok(result) => {
                if !result.valid {
                    error!("Invalid auth token for device: {}", device_hash);
                    return Err(Status::unauthenticated("Invalid authentication token"));
                }
                result
            },
            Err(e) => {
                error!("Token verification error for device {}: {}", device_hash, e);
                return Err(Status::unauthenticated("Invalid authentication"));
            }
        };
        
        let account_hash = auth_result.account_hash; // ÌÜ†ÌÅ∞ÏóêÏÑú Ï∂îÏ∂úÌïú Ïã§Ï†ú account_hash ÏÇ¨Ïö©
        
        // ÏöîÏ≤≠Îêú account_hashÏôÄ Îã§Î•¥Î©¥ Í≤ΩÍ≥† Î°úÍ∑∏ Ï∂úÎ†• (ÌïòÏßÄÎßå ÏóêÎü¨Îäî ÏïÑÎãò)
        if req.account_hash != account_hash {
            warn!("Client sent different account_hash (requested: {}, actual: {}) for device: {}", 
                  req.account_hash, account_hash, device_hash);
        }
        
        // Íµ¨ÎèÖ Ï±ÑÎÑê ÏÉùÏÑ± - Îçî ÌÅ∞ Î≤ÑÌçº ÏÇ¨Ïö©
        let (tx, rx) = mpsc::channel(1024);
        let stream = ReceiverStream::new(rx);
        
        // Íµ¨ÎèÖÏûê Îì±Î°ù (device_hashÎ•º ÌÇ§Î°ú ÏÇ¨Ïö©)
        let subscriber_key = format!("{}:{}", account_hash, device_hash);
        
        // Ïó∞Í≤∞ ÏÉÅÌÉú Ï∂îÏ†Å Îì±Î°ù
        let connection_key = self.app_state.connection_tracker
            .register_connection(device_hash.clone(), account_hash.clone()).await;
        
        match self.app_state.notification_manager.register_file_update_subscriber(
            subscriber_key.clone(), 
            tx
        ).await {
            Ok(_) => {
                // Íµ¨ÎèÖ Ìï¥Ï†úÎ•º Ï≤òÎ¶¨ÌïòÍ∏∞ ÏúÑÌïú Î∞±Í∑∏ÎùºÏö¥Îìú ÏûëÏóÖ
                let notification_manager = self.app_state.notification_manager.clone();
                let connection_tracker = self.app_state.connection_tracker.clone();
                let subscriber_key_clone = subscriber_key.clone();
                let connection_key_clone = connection_key.clone();
                tokio::spawn(async move {
                    // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞Ïù¥ Ï¢ÖÎ£åÎêòÎ©¥ ÏûêÎèôÏúºÎ°ú Íµ¨ÎèÖ Ìï¥Ï†ú
                    // Îçî Í∏¥ ÌÉÄÏûÑÏïÑÏõÉ ÏÇ¨Ïö© (7Ïùº) - Ïã§Ï†úÎ°úÎäî Ïó∞Í≤∞ Ï¢ÖÎ£å Ïãú Ìï¥Ï†úÎê®
                    tokio::time::sleep(tokio::time::Duration::from_secs(3600 * 24 * 7)).await;
                    
                    // Íµ¨ÎèÖ Ìï¥Ï†ú ÏãúÎèÑ
                    info!("Unregistering file update subscriber (timeout): {}", subscriber_key_clone);
                    if let Err(e) = notification_manager.unregister_file_update_subscriber(&subscriber_key_clone).await {
                        error!("Error unregistering subscriber: {:?}", e);
                    }
                    
                    // Ïó∞Í≤∞ ÏÉÅÌÉúÎ•º disconnectedÎ°ú ÎßàÌÇπ
                    connection_tracker.mark_disconnected(&connection_key_clone).await;
                });
                
                // TODO: Ïû¨ÏãúÎèÑ Î©îÏª§ÎãàÏ¶òÏù¥ ÌïÑÏöîÌïú Í≤ΩÏö∞ Ïó¨Í∏∞Ïóê Íµ¨ÌòÑ
                // ÌòÑÏû¨Îäî Ï¥àÍ∏∞ ÎèôÍ∏∞ÌôîÎ°ú ÎåÄÏ≤¥
                
                // Ï¥àÍ∏∞ ÎèôÍ∏∞Ìôî: Í∏∞Ï°¥ ÌååÏùºÎì§Ïóê ÎåÄÌïú ÏïåÎ¶º Ï†ÑÏÜ°
                if let Err(e) = self.send_initial_file_sync(&account_hash, &device_hash).await {
                    warn!("Failed to send initial file sync to {}:{}: {}", account_hash, device_hash, e);
                }
                
                info!("File updates subscription registered successfully for: {}", subscriber_key);
                Ok(Response::new(Box::pin(stream) as Self::SubscribeToFileUpdatesStream))
            },
            Err(e) => {
                error!("Failed to register file update subscriber: {:?}", e);
                Err(Status::internal(format!("Failed to register subscriber: {}", e)))
            }
        }
    }
    
    async fn subscribe_to_watcher_preset_updates(
        &self,
        request: Request<SubscribeRequest>,
    ) -> Result<Response<Self::SubscribeToWatcherPresetUpdatesStream>, Status> {
        debug!("Watcher preset updates subscription request received");
        
        let req = request.into_inner();
        let device_hash = req.device_hash;
        
        // Î®ºÏ†Ä ÌÜ†ÌÅ∞ÏùÑ Í≤ÄÏ¶ùÌïòÍ≥† Ïã§Ï†ú account_hashÎ•º Í∞ÄÏ†∏Ïò¥
        let auth_result = match self.app_state.oauth.verify_token(&req.auth_token).await {
            Ok(result) => {
                if !result.valid {
                    error!("Invalid auth token for device: {}", device_hash);
                    return Err(Status::unauthenticated("Invalid authentication token"));
                }
                result
            },
            Err(e) => {
                error!("Token verification error for device {}: {}", device_hash, e);
                return Err(Status::unauthenticated("Invalid authentication"));
            }
        };
        
        let account_hash = auth_result.account_hash; // ÌÜ†ÌÅ∞ÏóêÏÑú Ï∂îÏ∂úÌïú Ïã§Ï†ú account_hash ÏÇ¨Ïö©
        
        // ÏöîÏ≤≠Îêú account_hashÏôÄ Îã§Î•¥Î©¥ Í≤ΩÍ≥† Î°úÍ∑∏ Ï∂úÎ†• (ÌïòÏßÄÎßå ÏóêÎü¨Îäî ÏïÑÎãò)
        if req.account_hash != account_hash {
            warn!("Client sent different account_hash (requested: {}, actual: {}) for device: {}", 
                  req.account_hash, account_hash, device_hash);
        }
        
        // Ïû•Ïπò Í≤ÄÏ¶ù
        let is_dev_mode = std::env::var("COSMIC_SYNC_DEV_MODE").unwrap_or_default() == "1";
        let is_test_mode = std::env::var("COSMIC_SYNC_TEST_MODE").unwrap_or_default() == "1";
        
        if !is_dev_mode && !is_test_mode {
            let is_valid_device = match self.app_state.storage.validate_device(&account_hash, &device_hash).await {
                Ok(valid) => valid,
                Err(e) => {
                    error!("Error validating device: {}", e);
                    return Err(Status::internal("Error validating device"));
                }
            };
            
            if !is_valid_device {
                return Err(Status::unauthenticated("Invalid device"));
            }
        }
        
        // Ï±ÑÎÑê ÏÉùÏÑ± - Î≤ÑÌçº ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä
        let (tx, rx) = mpsc::channel(1024);
        let stream = ReceiverStream::new(rx);
        
        // Íµ¨ÎèÖ ÌÇ§ ÏÉùÏÑ±
        let sub_key = format!("{}:{}", account_hash, device_hash);
        
        // Í∏∞Ï°¥ Íµ¨ÎèÖÏù¥ ÏûàÏúºÎ©¥ Ìï¥Ï†ú (Ï§ëÎ≥µ Íµ¨ÎèÖ Î∞©ÏßÄ)
        match self.app_state.notification_manager.unregister_watcher_preset_update_subscriber(&sub_key).await {
            Ok(true) => debug!("Removed existing watcher preset subscription: {}", sub_key),
            Ok(false) => debug!("No existing watcher preset subscription to remove: {}", sub_key),
            Err(e) => warn!("Failed to remove existing preset subscription: {:?}", e),
        }
        
        // NotificationManagerÏóê Íµ¨ÎèÖÏûê Îì±Î°ù
        if let Err(e) = self.app_state.notification_manager.register_watcher_preset_update_subscriber(sub_key.clone(), tx).await {
            error!("Failed to register watcher preset update subscriber: {:?}", e);
            return Err(Status::internal(format!("Failed to register preset subscriber: {}", e)));
        }
        
        info!("Registered watcher preset update subscriber: {}", sub_key);
        
        Ok(Response::new(Box::pin(stream) as Self::SubscribeToWatcherPresetUpdatesStream))
    }
    
    async fn subscribe_to_watcher_group_updates(
        &self,
        request: Request<SubscribeRequest>,
    ) -> Result<Response<Self::SubscribeToWatcherGroupUpdatesStream>, Status> {
        debug!("Watcher group updates subscription request received");
        
        let req = request.into_inner();
        let device_hash = req.device_hash;
        
        // Î®ºÏ†Ä ÌÜ†ÌÅ∞ÏùÑ Í≤ÄÏ¶ùÌïòÍ≥† Ïã§Ï†ú account_hashÎ•º Í∞ÄÏ†∏Ïò¥
        let auth_result = match self.app_state.oauth.verify_token(&req.auth_token).await {
            Ok(result) => {
                if !result.valid {
                    error!("Invalid auth token for device: {}", device_hash);
                    return Err(Status::unauthenticated("Invalid authentication token"));
                }
                result
            },
            Err(e) => {
                error!("Token verification error for device {}: {}", device_hash, e);
                return Err(Status::unauthenticated("Invalid authentication"));
            }
        };
        
        let account_hash = auth_result.account_hash; // ÌÜ†ÌÅ∞ÏóêÏÑú Ï∂îÏ∂úÌïú Ïã§Ï†ú account_hash ÏÇ¨Ïö©
        
        // ÏöîÏ≤≠Îêú account_hashÏôÄ Îã§Î•¥Î©¥ Í≤ΩÍ≥† Î°úÍ∑∏ Ï∂úÎ†• (ÌïòÏßÄÎßå ÏóêÎü¨Îäî ÏïÑÎãò)
        if req.account_hash != account_hash {
            warn!("Client sent different account_hash (requested: {}, actual: {}) for device: {}", 
                  req.account_hash, account_hash, device_hash);
        }
        
        // Ïû•Ïπò Í≤ÄÏ¶ù
        let is_dev_mode = std::env::var("COSMIC_SYNC_DEV_MODE").unwrap_or_default() == "1";
        let is_test_mode = std::env::var("COSMIC_SYNC_TEST_MODE").unwrap_or_default() == "1";
        
        if !is_dev_mode && !is_test_mode {
            let is_valid_device = match self.app_state.storage.validate_device(&account_hash, &device_hash).await {
                Ok(valid) => valid,
                Err(e) => {
                    error!("Error validating device: {}", e);
                    return Err(Status::internal("Error validating device"));
                }
            };
            
            if !is_valid_device {
                return Err(Status::unauthenticated("Invalid device"));
            }
        }
        
        // Ï±ÑÎÑê ÏÉùÏÑ± - Î≤ÑÌçº ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä
        let (tx, rx) = mpsc::channel(1024); // Î≤ÑÌçº ÌÅ¨Í∏∞Î•º 1024Î°ú Ï¶ùÍ∞Ä (Ïù¥Ï†Ñ 128)
        let stream = ReceiverStream::new(rx);
        
        // Íµ¨ÎèÖ ÌÇ§ ÏÉùÏÑ±
        let sub_key = format!("{}:{}", account_hash, device_hash);
        
        // Í∏∞Ï°¥ Íµ¨ÎèÖÏù¥ ÏûàÏúºÎ©¥ Ìï¥Ï†ú (Ï§ëÎ≥µ Íµ¨ÎèÖ Î∞©ÏßÄ)
        match self.app_state.notification_manager.unregister_watcher_group_update_subscriber(&sub_key).await {
            Ok(true) => debug!("Removed existing watcher group subscription: {}", sub_key),
            Ok(false) => debug!("No existing watcher group subscription to remove: {}", sub_key),
            Err(e) => warn!("Failed to remove existing subscription: {:?}", e),
        }
        
        // NotificationManagerÏóê Íµ¨ÎèÖÏûê Îì±Î°ù
        if let Err(e) = self.app_state.notification_manager.register_watcher_group_update_subscriber(sub_key.clone(), tx).await {
            error!("Failed to register watcher group update subscriber: {:?}", e);
            return Err(Status::internal(format!("Failed to register subscriber: {}", e)));
        }
        
        info!("Registered watcher group update subscriber: {}", sub_key);
        
        // Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏Ïö© Ï¥àÍ∏∞ Î©îÏãúÏßÄ Ï†ÑÏÜ° (PING Ïó≠Ìï†)
        let heartbeat_interval = std::env::var("HEARTBEAT_INTERVAL_SECS")
            .ok()
            .and_then(|s| s.parse::<u64>().ok())
            .unwrap_or(10); // Í∏∞Î≥∏Í∞í 10Ï¥àÎ°ú Îã®Ï∂ï (Ïù¥Ï†Ñ 30Ï¥à)
        
        // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅÏùÑ ÏúÑÌïú ÌÉúÏä§ÌÅ¨
        let notification_manager_clone = self.app_state.notification_manager.clone();
        let sub_key_clone = sub_key.clone();
        let account_hash_clone = account_hash.clone();
        let device_hash_clone = device_hash.clone();
        
        tokio::spawn(async move {
            // Ï¥àÍ∏∞Ìôî ÏßÄÏó∞
            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
            debug!("Starting watcher group updates monitoring for {}", sub_key_clone);
            
            let mut keep_alive_interval = tokio::time::interval(tokio::time::Duration::from_secs(heartbeat_interval));
            let mut failure_count = 0;
            let max_failures = 3; // ÏµúÎåÄ 3Î≤àÏùò Ïã§Ìå® ÌõÑ Íµ¨ÎèÖ Ìï¥Ï†ú
            
            loop {
                tokio::select! {
                    _ = keep_alive_interval.tick() => {
                        // Íµ¨ÎèÖÏûê Ïó¨Ï†ÑÌûà ÌôúÏÑ± ÏÉÅÌÉúÏù∏ÏßÄ ÌôïÏù∏
                        let is_active = notification_manager_clone.is_watcher_group_subscriber_active(&sub_key_clone).await;
                        if !is_active {
                            debug!("Watcher group subscriber {} no longer active, stopping monitoring", sub_key_clone);
                            break;
                        }
                        
                        // Ïó∞Í≤∞Ïù¥ ÌôúÏÑ± ÏÉÅÌÉúÏù∏ÏßÄ ping Î©îÏãúÏßÄ Ï†ÑÏÜ°ÏùÑ ÏãúÎèÑ
                        let ping_notification = WatcherGroupUpdateNotification {
                            account_hash: account_hash_clone.clone(),
                            device_hash: device_hash_clone.clone(),
                            group_data: None, // Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå (Ìïë Î™©Ï†Å)
                            update_type: 0, // CREATED
                            timestamp: chrono::Utc::now().timestamp(),
                        };
                        
                        // ÌäπÏ†ï Íµ¨ÎèÖÏûêÏóêÍ≤åÎßå Ìïë Ï†ÑÏÜ°
                        match notification_manager_clone.ping_watcher_group_subscriber(&sub_key_clone, ping_notification).await {
                            Ok(_) => {
                                // ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ÑÏÜ°ÎêòÎ©¥ Ïã§Ìå® Ïπ¥Ïö¥Ìä∏ Î¶¨ÏÖã
                                failure_count = 0;
                            },
                            Err(_) => {
                                // Ï†ÑÏÜ° Ïã§Ìå®Ïãú Ïã§Ìå® Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
                                failure_count += 1;
                                warn!("Failed to ping watcher group subscriber {}, failure count: {}/{}", 
                                    sub_key_clone, failure_count, max_failures);
                                
                                if failure_count >= max_failures {
                                    warn!("Max failures reached for {}, unregistering subscriber", sub_key_clone);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            
            // Íµ¨ÎèÖ Ìï¥Ï†ú - Ï§ëÎ≥µ Ìò∏Ï∂ú Î∞©ÏßÄÎ•º ÏúÑÌï¥ Ìïú Î≤àÎßå ÏãúÎèÑ
            match notification_manager_clone.unregister_watcher_group_update_subscriber(&sub_key_clone).await {
                Ok(true) => {
                    info!("Unregistered watcher group update subscriber: {}", sub_key_clone);
                },
                Ok(false) => {
                    debug!("Watcher group update subscriber {} was already removed", sub_key_clone);
                },
                Err(e) => {
                    warn!("Failed to unregister watcher group update subscriber: {:?}", e);
                }
            }
        });
        
        Ok(Response::new(Box::pin(stream) as Self::SubscribeToWatcherGroupUpdatesStream))
    }

    // Version management methods implementation
    async fn get_file_history(
        &self,
        request: Request<GetFileHistoryRequest>,
    ) -> Result<Response<GetFileHistoryResponse>, Status> {
        match self.sync_handler.get_file_history(request).await {
            Ok(response) => Ok(response),
            Err(status) => Err(status),
        }
    }

    async fn restore_file_version(
        &self,
        request: Request<RestoreFileVersionRequest>,
    ) -> Result<Response<RestoreFileVersionResponse>, Status> {
        match self.sync_handler.restore_file_version(request).await {
            Ok(response) => Ok(response),
            Err(status) => Err(status),
        }
    }

    async fn broadcast_file_restore(
        &self,
        request: Request<BroadcastFileRestoreRequest>,
    ) -> Result<Response<BroadcastFileRestoreResponse>, Status> {
        match self.sync_handler.broadcast_file_restore(request).await {
            Ok(response) => Ok(response),
            Err(status) => Err(status),
        }
    }

    type SubscribeToVersionUpdatesStream = std::pin::Pin<
        Box<dyn futures::Stream<Item = Result<VersionUpdateNotification, Status>> + Send + 'static>
    >;

    async fn subscribe_to_version_updates(
        &self,
        request: Request<SubscribeRequest>,
    ) -> Result<Response<Self::SubscribeToVersionUpdatesStream>, Status> {
        debug!("Version updates subscription requested");
        
        let (tx, rx) = mpsc::channel(128);
        
        // Create a stream from the receiver
        let stream = tokio_stream::wrappers::ReceiverStream::new(rx).map(|notification| {
            Ok(notification)
        });
        
        Ok(Response::new(Box::pin(stream) as Self::SubscribeToVersionUpdatesStream))
    }
}

/// Synchronization client service implementation
pub struct SyncClientServiceImpl {
    /// Application state
    app_state: Arc<AppState>,
    /// Authentication handler
    auth_handler: AuthHandler,
}

impl SyncClientServiceImpl {
    /// Create a new SyncClientServiceImpl instance
    pub fn new(app_state: Arc<AppState>) -> Self {
        let auth_handler = AuthHandler::new(app_state.clone());
        
        Self {
            app_state,
            auth_handler,
        }
    }
}

#[tonic::async_trait]
impl SyncClientService for SyncClientServiceImpl {
    async fn notify_auth_success(
        &self,
        request: Request<AuthSuccessNotification>,
    ) -> Result<Response<AuthNotificationResponse>, Status> {
        debug!("Auth success notification received");
        
        // TODO: Ïù∏Ï¶ù ÏÑ±Í≥µ Î©îÏãúÏßÄ Ï≤òÎ¶¨ Íµ¨ÌòÑ
        
        Ok(Response::new(AuthNotificationResponse {
            success: true,
            return_message: "Notification received".to_string(),
        }))
    }
} 